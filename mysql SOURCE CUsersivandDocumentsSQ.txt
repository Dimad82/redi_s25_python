mysql> SOURCE C:/Users/ivand/Documents/SQL/SKRIPTE/DVDSTAR.SQL;

Code/1_NumericDataType.py

########################
## TYPE int: INTEGERS ##
########################

# Keep in mind throughout the course: EVERYTHING IN PYTHON IS AN OBJECT. This
# will become clearer as you progress through the course.

# Objects of type int represent integer values in Python. An integer is a whole
# number, positive and negative. 
#
# Run the following lines of code in the Console / Terminal and see what you 
# get as output!
# 
#   - For Mac, press the CONTROL and backtick (^ + `) keys or click on the 
#     Terminal menu and click New Terminal.
#   - For Windows, press CONTROL and backtick (CTRL + `) keys or click on 
#     the Terminal menu and click New Terminal. Terminal menu on Windows 
#     may be shown as Console.

x = 2           # Assign the value of 2 to the variable x
x               # Print the content of variable x
type(x)         # Print the type of variable x. What type do you get?

# Python includes many basic operations between integers, for example
# addition and subtraction. Run the following lines of code in the 
# console / terminal and see what happens!
5 + 2      # Addition
5 - 2      # Subtraction
5 * 2      # Multiplication
5 / 2      # Division (returns both the integer and decimal portions)
5 // 2     # Integer division (returns only the integer portion)
5 % 2      # Modulo division (returns only the decimal portion)
5 ** 2     # Exponentiation
min(2, 5)  # Minimum
max(2, 5)  # Maximum

# EXERCISE 1: What is the type of the expressions above? Are they all 
# of type int? You can check using the function type() as in the line below.
type(5 + 2)


# In addition to the operations above there are many more operations
# and functions already defined. Check the official documentation for more 
# information!
# https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex

# We can also write more complex expressions using parentheses and assign the 
# resulting value to a variable for later use. Try to run the following lines 
# in the Console / Terminal!
x = (1 + 2) - (3 * 4)
y = 2 * x
z = 27 + x + y
print("The value of x is", x, "the value of y is", y, "and the value of z is",
      z)

# Remember that parentheses work from the inside out. The inner most set of
# parentheses are evaluated first and then it move out one level, evaluates
# the next set of parentheses and so on.

########################################
## TYPE float: FLOATING POINT NUMBERS ##
########################################

# Objects of type float represent floating point values in python. A floating 
# point value is a number with a decimal or fractional part, such as 1.25
x = 1.25        # Assign to the variable x the value 1.25
x               # Print the content of variable x
type(x)         # Print the type of variable x. What type do you get?

"""
We used the variable x already in the examples for the integer type.
In the previous examples type(x) returned 'int' as output, but in this 
example type(x) gives 'float' as output.

So type(x) does not output the type of the variable x, but the type of 
the current content of x. Variables in Python do not have a type!
"""

# We can use the operations in the previous example also with floats.
# Run the following lines of code in the console and see what happens!
5. + 2.
5. - 2.
5. * 2.
5. / 2.
5. // 2.
5. % 2.
5. ** 2.
min(2., 5.)
max(2., 5.)

# EXERCISE 2: What is the type of the expressions above? Any interesting 
# observations? Example:
type(5. + 2.)


# We can use int and float values together in the same expressions, as 
# in the following examples. 

# EXERCISE 3: What is the type of the resulting expressions?
x = 3 + 2.5
y = 2.5 * 3
z = (1.5 + .5) // 2
print("The value of x is", x, "the value of y is", y, "and the value of z is",
      z)

# A 'type conversion' occurred above when assigning values to x and y. 
# Assigning to x, 3 is an integer and 2.5 is a float. Entering type(x) 
# shows that the data in x is a float. When combining int and float, 
# the result will always be a float, unless you use the int() function 
# to convert the result to an int. But remember, you can have data loss 
# if you do this. You can test this with the following code:
x = 3 + int(2.5)
x
type(x)

# The functions int() and float() convert the data provided to them to
# either an integer or a float respectively. In the example above you
# called the int() function with a float value. This converted the float 
# to an integer and the .5 portion was dropped. Be careful, you can lose 
# data precision or generate an error when doing this. For example,
# try this: (commented out since it will produce an error)
# x = 3 + int("ReDI")
# x
# type(x)

# The first statement generated an error because we can't pass in
# the text "ReDI" to the int() function...it doesn't make sense. 
# But, you can try this:
x = 3 + int("10")
x
type(x)

# This works because Python can convert the string "13" to an
# integer 13 as part of the expression.

Code/2_Strings

#######################
## TYPE str: STRINGS ##
#######################

# Objects of type str represent strings, that is, pieces of text. All the 
# following are examples of strings. Try to print them in the console / 
# terminal using the print() function.
single_word         = "Ciao"
two_words           = "Hello World"
special_characters  = "Aan;EA!@#2109412"
big_text            = """
    In the midst of the journey of our life
I found myself through a dark forest
For the straight way was lost.

    Ah me! how hard a thing it is to say
What was this forest savage, rough, and stern,
Which in the very thought renews the fear.

Inferno, Canto I, Dante Alighieri
https://poets.org/poem/inferno-canto-i

"""
empty_string = ""  # The empty string does not contain any characters!

# Notice that we can define strings in different ways. The following 
# variables have all the same content. However, we need to use triple-
# quotes for multi-line comments, such as the big_text above.
#
# Key point, pick the one you prefer and use it consistently. Don't
# mix them throughout your code.
string_hw_one    = 'Hello World!'
string_hw_two    = "Hello World!"
string_hw_three  = '''Hello World!'''
string_hw_four   = """Hello World!"""

# There are also other ways to create strings, for example starting 
# from other objects, by calling the str() function.
another_definition      = str()        # An empty string
yet_another_definition  = str("Ciao")  # A string containing the word "Ciao"
string_from_a_number    = str(15)      # A string generated from an object of type int


"""
We already saw that we can use triple-quotes to insert multi-line 
comments like this one. The same syntax is used for multi-line 
strings as shown above. But do not confuse the two, comments have 
no impact on the code but multi-line strings do!
"""

# Python comes with many useful operations on strings, like the following 
# ones.
first_string  = "pine"
second_string = "apple"
single_space  = " "
len(first_string)                    # Returns the length of the string, 
                                     # how many characters it has.
first_string.replace('n', 'l')       # Returns a string where every 
                                     # occurrence of 'n' is substituted 
                                     # with 'l'
second_string.replace('p', '[]')     # Returns a string where every 
                                     # occurrence of 'p' is substituted 
                                     # with '[]'
first_string.find('i')               # Find the position of the first 
                                     # occurrence of 'i' in the string (the 
                                     # first character has position 0, the 
                                     # second has position 1, etc.
                                     # (See below for more info)
second_string.count('p')             # Counts the number of occurrences of 
                                     # 'p' in the string
first_string + second_string         # Concatenates or merges the two 
                                     # strings

# All collections in Python are zero-based. This means that the first item in 
# the collection starts at index zero. Consider the text "While my guitar 
# gently weeps" and see how the indexes are assigned to each letter.
#
# 0000000000111111111122222222
# 0123456789012345678901234567
# While my guitar gently weeps
#
# Try it out:
lyric = "While my guitar gently weeps"
len(lyric)
lyric[5]
lyric[15]
lyric[25]
#lyric[35]

# The last statement results in a "string index out of range" error. This 
# is because the length of the string is 28 characters and the indexes for 
# each letter run from 0 to 27. The statement lyric[35] is invalid because 
# the string has only 28 characters.
#
# You can also go backwards through a string. Try it out:
lyric[-5]
lyric[-15]
lyric[-25]
#lyric[-35]

# We encounter the same index out of range error with the last statement. 
# Again, there are only 28 characters in the string so -35 is an invalid 
# index.

# This zero-based index concept is common among the majority of programming
# languages today.

# For more functions on strings, check the official documentation!
# https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str

"""
If you print the value of first_string and second_string in the 
console / terminal, you will see that their content has not changed. 
This means that the functions above do not change the content of the 
two variables, but rather return new strings with the altered content.
"""

# EXERCISE 1:
# 1) Store your name, nickname and favorite color in three different 
#    variables. You can hardcode the values or you can use the input()
#    function to obtain the values when you run the program (i.e. at
#    'runtime'))
# 2) Print the three variables in order in the following format: 
#    "<name> -- <nickname> -- <favorite color>"
#
#    Example: "Gianluca -- GG -- aqua"


# EXERCISE 2: Take the following text belo and write a program that prints 
#             the following information:
# 1) How many times the words "Lorem" and "Ipsum" appear in the text
# 2) The indexes of the first occurrence of the two words
# 3) (BONUS): The index of the last occurrence of the two words.
# 4) (BONUS): The strings "Lorem" and "lorem" both appear in the text, but 
# are considered different strings because of the capital/non-capital 
# letters. Find how many times the word appears *disregarding capitalization*.
# HINT: Search online for additional functions for strings to solve the 
# bonus exercises!
lore_ipsum_text = """Lorem Ipsum is simply dummy text of the printing 
and typesetting industry. Lorem Ipsum has been the industry's standard 
dummy text ever since the 1500s, when an unknown printer took a galley 
of type and scrambled it to make a type specimen book. It has survived 
not only five centuries, but also the leap into electronic typesetting, 
remaining essentially unchanged. It was popularised in the 1960s with 
the release of Letraset sheets containing Lorem Ipsum passages, and 
more recently with desktop publishing software like Aldus PageMaker 
including versions of lorem Ipsum."""


# EXERCISE 3: Ask the user for two numbers and store them in variables.
# Multiply the two numbers together and display the result to the user.
# HINT: In the previous section on numerics, two functions were covered.
# You may need them here. We want to perform multiplication, not string
# concatenation.


# The None data type represents the absence of data in an object. None
# is equivalent to null in other languages. To learn more about the None
# see https://docs.python.org/3/reference/datamodel.html#none and 
# https://realpython.com/null-in-python/, although this second article
# provides a much more detailed explanation with examples.

Code/3_Boolean.py

############################
## TYPE bool: TRUTH-VALUE ##
############################

# Objects of type bool have only two possible values: True and False. True and
# False are keywords in Python.
true_var  = True
false_var = False

# We can produce bool variables also starting from objects of different types, 
# like shown in the following examples. Play a bit with them in the console / 
# terminal!
bool_from_int   = bool(0)        # int  : 0 is casted to False, all other 
                                 #        values to True
bool_from_float = bool(0.1)      # float: 0.0 is casted to False, all other 
                                 #        values to True
bool_from_str   = bool('False')  # str  : the empty string is casted to 
                                 #        False, all others are True

# There is another way to produce truth values starting from other objects, 
# that is, using COMPARISON OPERATORS. The following are some examples. Test 
# them out!
'ab' == 'ba' # Equivalent
'ab' != 'ba' # Not equivalent
.5   >  1.5  # Greater than
.5   <  1.5  # Less than
2    >= 3    # Greater than or equal to
2    <= 3    # Less than or equal to

# NOTE: the single equal operator '=' is called assignment. This puts something 
#       into something else. For example, x = 10 puts 10 into x. The double equal
#       operator '==' along with the not equal operator '!=' tests for equivalency.
#       Often when we read the code, we will say 'does x equal y' or 'is x not 
#       equal to y'. But these statements are comparitive, not assignment.

# Python implements basic LOGICAL OPERATORS between boolean values, like the 
# followings.
True and False    # Logical conjunction, and
True or  False    # Logical disjunction, or
not True          # Negation, not

# The 'and' and 'or' operators are used when more than one condition or 
# expression is present. For example, "if it is evening AND the 
# temperature outside is above 20 degrees then I'm going to go outside."
# When using 'and' BOTH conditions must be True for the entire statement 
# to be true.
#
# Another example would be "if it is raining outside OR it is snowing outside 
# then I'm going to stay inside." When using 'or' BOTH conditions must be False 
# for the entire statement to be false.

# The comparison operators used together with the logical operators allow to 
# test complex conditions.

Code/4_If_Elif_Else.py

################
## CONDITIONS ##
################

# Often we want to run a piece of code only if certain conditions are met.
# Python allows to do that using the "if" statement. Copy-paste and run 
# the following code.
if True:
    print("This code prints something!")

if False:
    print("This code does not print anything!")

# The object between the keyword "if" and the ":" is called a condition and
# can be a variable or an expression. The statement is evaluated using the 
# same rules as bool()
x = 10
if x == 10:
    print("The content of x is 10!")

y = 1
if y:
    print("The integer y is evaluated as True, so it means that the value stored is not 0.")
  
# In the code above, we run a single line of code in each if statement. But we 
# can also run multiple lines of code, as the following example shows
if True:
    print("First line")
    print("Second line")
    x = 3 + 3 - 4
    print("Third line... and content of the variable x:", x)

# But how does Python know how many lines of code should be executed if the 
# condition is met? Try to run the following lines of code. Do you see the
# difference compared to the previous code?
if False:
    print("First line")
    print("Second line")
x = 3 + 3 - 4
print("Third line... and content of the variable x:", x)

"""
Python uses indentation to group together different lines of code!

Since the indentation on lines 37 and 38 is the same, they form a group of 
code UNDER the if statement and since their indentation is larger or deeper
than that of the if statement (line 36), they are under the scope of the if 
statement. This means lines 37 and 38 will only run if the condition in 
line 36 results in True. Lines 39 and 40 have the same level or depth of 
indentation of the if statement (line 36), so they are not affected by the 
if statement; they are outside the scope of the if statement. 

We will see that the same rules for grouping lines of code apply also for 
other constructs and statements.
"""

# EXERCISE 1: Write a function that:
# 1) Asks the user to input their name, surname and age (code included)
# 2) Prints True if the user is named John Johnson and he his 18 or older
# 3) Otherwise print False.
# 4) Use ONLY the if statement to do this.
first_name = input("Enter your first name: ")
last_name = input("Enter your last name: ")
age = int(input("Enter your age: "))


# EXERCISE 2: Write a program that asks the user to give a string as input and:
# Case 1) if the string contains more than 3 characters, prints the number 1
# Case 2) otherwise, prints the number 0
user_string = input("Enter any string: ")


"""
With only the "if" statements introduced above, EXERCISES 1 and 2 requires 
two "if" statements, one for each condition we needed to test. But there is 
# a much more compact and proper way to solve the exercise: using if..else 
statements!
"""

# An if..else statement, similarly to the if statement, checks a condition and:
# Case 1) if the statement is true, then runs a certain piece of code;
# Case 2) if the statement is false, then runs a different piece of code.
# Run the next piece of code. Then try to change the value of the variable 
# "test" to something else and see what happens!
test = True
if test:
    print("The value of test is True.")
else:
    print("The value of test is False.")

# EXERCISE 3: Solve EXERCISE 1 using an if..else statement.
first_name = input("Enter your first name: ")
last_name = input("Enter your last name: ")
age = int(input("Enter your age: "))


# To deal with more complicated conditions we can *nest* several if statements 
# into the other, as the following piece of code shows. Try to change the value 
# of first_test and second_test!
first_test  = True
second_test = True
if first_test:
    print("first_test is True.")
else:
    if second_test:
        print("first_test is False and second_test is True.")
    else:
        print("first_test and second_test are both False.")

# Once again, there is a cleaner way to write the previous code, that is, 
# using the if..elif..else statement. The previous code does the same as the 
# following. Test it out!
first_test  = True
second_test = True
if first_test:
    print("first_test is True.")
elif second_test:
    print("first_test is False and second_test is True.")
else:
    print("first_test and second_test are both False.")

# The if..elif..else tests the conditions after the "if" and "elif" keywords 
# one at a time top down, and runs the piece of code corresponding to the 
# first true condition found. And if none of the conditions are true, then it 
# runs the code corresponding to the "else" keyword. You can have as many 
# "elif" statements as you want. Test it with the following and change the 
# the value of warehouse_content to execute the different conditions.
warehouse_capacity = 1000
warehouse_content  = 300
if warehouse_content <= warehouse_capacity * 0.25:
    print("Capacity in the warehouse: more than 75%")
elif warehouse_content <= warehouse_capacity * 0.5:
    print("Capacity in the warehouse: more than 50%")
elif warehouse_content <= warehouse_capacity * 0.75:
    print("Capacity in the warehouse: more than 25%")
elif warehouse_content <= warehouse_capacity:
    print("Attention! Less than 25% capacity in the warehouse!")
else:
    print("Warehouse capacity exceeded!")


# EXERCISE 4: Calculating income tax.
# Write a program that asks the user for their gross earnings for 2023.
# Upon having the earnings, calculate the income tax. Here is a breakdown
# of taxes owed:
#
#   0.00 - 32000.00: 0% tax
#   32000.01 - 50000.00: 15% tax
#   50000.01 - 100000.00: 25% tax
#   100000.01 - 250000.00: 37% tax
#   250000.01 - 500000.00: 42% tax
#   500000.01 and higher: 45% tax
#
# Once you calculate the tax, display it to the user. Be sure to take into 
# account negative numbers. A negative number for gross earnings is not valid.
  
gross_salary = float(input("What was your gross earnings for 2023: "))
computed_tax = 0.0

Code/5_Loops.py

###########
## LOOPS ##
###########

# Look at the following piece of code.
print("Printing number... 1")
print("Printing number... 2")
print("Printing number... 3")
print("Printing number... 4")
print("Printing number... 5")
print("Printing number... 6")
print("Printing number... 7")
print("Printing number... 8")
print("Printing number... 9")
print("Printing number... 10")

# This code is very redundant... We basically want to print the same string, 
# except for the number appearing at the end. Is there a more elegant/more 
# compact way to do this? Indeed there is! We can use a while loop! Try to 
# run the following code.
current_number = 1
max_printed_number = 10
while current_number <= max_printed_number:
    print("Printing number...", current_number)
    current_number += 1

"""
What is happening here? After the keyword "while" we have a condition 
(current_number <= max_printed_number). And after the colon, similarly 
to an if statement, we find an indented piece of code (lines 24 and 25).

When we run the code, what happens is that:
(1) the program checks whether the condition 
    (current_number <= max_printed_number) is True, and if this is the 
    case
(2) it runs the piece of code in lines 24 and 25, and then
(3) the programs loops back to line 23 to check the condition again

And what if the condition is False in line 23? Then the program does not 
run the code and stops checking the condition. It skips the indented code
and continues executing whatever code follows the while loop. Notice
that we say the "indented code". Just like if statements, indented code
under a while statement falls within the scope of that while statement.

Also notice like 25: current_number += 1. This is called a shorthand 
assignment operator. It means the same as the following:

current_number = current_number + 1

So, in a nutshell: the program keeps running lines 24 and 25 while the 
condition holds True.
"""

# EXERCISE 1: Try to change the initial values of current_number and 
# max_printed_number in the code above and see what happens!


# If you played around enough with the values in the previous exercise, 
# you probably noticed two things:
#    -> Sometimes the program does not run the code in the while 
#       statement. This happens when the condition is not true to 
#       start with. Check the following code!
while False:
    print("Too bad, this text will never see the light of day!")
#    -> Sometimes the program does not terminate. This happens when 
#       the condition holds true indefinitely. Check the following 
#       two examples, and be sure to stop the execution of the code 
#       manually! (Red square button in the upper right corner of
#       the editor.)
# while True:       # Commented out because it's an infinite loop.
#    print("This text will be printed until the end of time!")

negative_number = -5
# while negative_number < 0:    # Commented out, infinite loop
#     print("negative_number is still negative...")
#     negative_number -= 1      # Shorthand for 
#                                 negative_number = negative_number - 1


# Notice that we might not be able to tell how many times the code in the 
# while statement will be executed. For example, in the following piece of 
# code, the user decides how many times the text is printed!
lines_to_print = int(input("How many lines should be printed: "))
lines_printed = 0
while lines_printed < lines_to_print:
    print("This is a line!")
    lines_printed += 1      # If you omit this line, you will have an
                            # infinite loop. Why?

# EXERCISE 2: Write a program that asks the user to input a number x and
#   Case 1) if x is negative, then it prints an error message
#   Case 2) if x is positive, then it prints the first x *even numbers*
# E.G.: if the input is 5, the program prints 2 4 6 8 10.
user_input = input("Enter any whole number: ")
x = int(user_input)      # The call to int() can be combined with input()
                         # on a single line.

    
# The while statement is *one* way to loop code in Python. But there are 
# more ways to do that! For example the following code, using the for 
# statement, is another way to eliminate the redundancy in the initial 
# example
for current_number in range(1, 11):
    print("Printing number...", current_number)

"""
How does this work? After the keyword "for" we provide a variable (in 
this case current_number). Then the code on line 104 is run several times, 
every time with a different value of current_number.

And how is the value of current_number determined at every iteration 
of the code? Range tracks numeric values from 1 to 11 exclusive. This 
means that the loop will run 10 times and the values printed will be 
1, 2, 3, 4, 5, 6, 7, 8, 9, 10. Once range hits 11, it sees this is the 
stop condition and ends the loop.
"""

# EXERCISE 3: Solve EXERCISE 2 using a for loop
user_input = input("Enter any whole number: ")
x = int(user_input)  # The call to int() can be combined with input()
                     # on a single line.


# EXERCISE 4: write a program that asks the user to input a number x and
#     Case 1) if x is negative, then it prints an error message
#     Case 2) if x is positive, then it prints the sum of the 
#             first x numbers
# E.G.: if the input is 5, the program prints 15 (which is 1+2+3+4+5)
user_input = input("Enter any whole number: ")
x = int(user_input)  # The call to int() can be combined with input()
                     # on a single line.

Code/6_FnalExerce.y

# Write a program that will do the following:
# 1. Continuously loop until the user enters the empty string. They can do
#    this by simply pressing Enter or Return without entering in any
#    characters.
# 2. Within the loop, ask the user to enter a string. Again, if they just 
#    press the Enter or Return key, this results in an "empty string". 
#    If they entered the empty string, end the loop. The empty string
#    in code is "". Otherwise...
# 3. Print out four different versions of the string using various string 
#    functions:
#       a) Print out the string with only the first letter capitalized. 
#       b) Print out the string in all lowercase.
#       c) Print out the string in title case. 
#       d) Print out the string in all uppercase.
# 4. Then loop around and ask the user for another string, following the 
#    logic above.
#
# Here is how the output might look like, but feel free to experiment with
# your code:
#
#   Enter a string: <user presses Enter>
#   Thanks for playing! <and the program ends>
#
# <Run the program again>
#
#   Enter a string: This Is a STRING with MiXeD casing.
#   First letter capitalized: This is a string with mixed casing.
#   All lowercase:            this is a string with mixed casing.
#   Title case:               This Is A String With Mixed Casing.
#   All uppercase:            THIS IS A STRING WITH MIXED CASING.
#   Enter a string: this is ANOTHER string with mixed casing.
#   First letter capitalized: This is another string with mixed casing.
#   All lowercase:            this is another string with mixed casing.
#   Title case:               This Is Another String With Mixed Casing.
#   All uppercase:            THIS IS ANOTHER STRING WITH MIXED CASING. 
#   Enter a string: <user presses Enter>
#   Thanks for playing! <and the program ends>

